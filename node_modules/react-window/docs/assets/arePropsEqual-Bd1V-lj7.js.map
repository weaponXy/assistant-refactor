{"version":3,"file":"arePropsEqual-Bd1V-lj7.js","sources":["../../src/components/Block.tsx","../../lib/utils/parseNumericStyleValue.ts","../../lib/utils/getRTLOffsetType.ts","../../lib/utils/adjustScrollOffsetForRtl.ts","../../lib/utils/assert.ts","../../lib/utils/shallowCompare.ts","../../lib/core/getEstimatedSize.ts","../../lib/core/getStartStopIndices.ts","../../lib/core/useCachedBounds.ts","../../lib/core/createCachedBounds.ts","../../lib/core/useVirtualizer.ts","../../lib/hooks/useResizeObserver.ts","../../lib/core/useItemSize.ts","../../lib/hooks/useStableCallback.ts","../../lib/core/getOffsetForIndex.ts","../../lib/hooks/useMemoizedObject.ts","../../lib/utils/arePropsEqual.ts"],"sourcesContent":["import type { HTMLAttributes, PropsWithChildren } from \"react\";\nimport { ErrorBoundary } from \"./ErrorBoundary\";\n\nexport function Block({\n  children,\n  className,\n  ...rest\n}: PropsWithChildren<HTMLAttributes<HTMLDivElement> & { className?: string }>) {\n  return (\n    <ErrorBoundary>\n      <div\n        className={`border-lg bg-black/30 text-slate-300 rounded-lg p-2 ${className}`}\n        {...rest}\n      >\n        {children}\n      </div>\n    </ErrorBoundary>\n  );\n}\n","import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n","export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n","export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n","import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): {\n  startIndexVisible: number;\n  stopIndexVisible: number;\n  startIndexOverscan: number;\n  stopIndexOverscan: number;\n} {\n  const maxIndex = itemCount - 1;\n\n  let startIndexVisible = 0;\n  let stopIndexVisible = -1;\n  let startIndexOverscan = 0;\n  let stopIndexOverscan = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndexVisible = currentIndex;\n  startIndexOverscan = Math.max(0, startIndexVisible - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndexVisible = Math.min(maxIndex, currentIndex);\n  stopIndexOverscan = Math.min(itemCount - 1, stopIndexVisible + overscanCount);\n\n  if (startIndexVisible < 0) {\n    startIndexVisible = 0;\n    stopIndexVisible = -1;\n    startIndexOverscan = 0;\n    stopIndexOverscan = -1;\n  }\n\n  return {\n    startIndexVisible,\n    stopIndexVisible,\n    startIndexOverscan,\n    stopIndexOverscan\n  };\n}\n","import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n","import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { shallowCompare } from \"../utils/shallowCompare\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const [indices, setIndices] = useState<{\n    startIndexVisible: number;\n    stopIndexVisible: number;\n    startIndexOverscan: number;\n    stopIndexOverscan: number;\n  }>({\n    startIndexVisible: 0,\n    startIndexOverscan: 0,\n    stopIndexVisible: -1,\n    stopIndexOverscan: -1\n  });\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const {\n    startIndexVisible,\n    startIndexOverscan,\n    stopIndexVisible,\n    stopIndexOverscan\n  } = {\n    startIndexVisible: Math.min(itemCount - 1, indices.startIndexVisible),\n    startIndexOverscan: Math.min(itemCount - 1, indices.startIndexOverscan),\n    stopIndexVisible: Math.min(itemCount - 1, indices.stopIndexVisible),\n    stopIndexOverscan: Math.min(itemCount - 1, indices.stopIndexOverscan)\n  };\n\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (shallowCompare(next, prev)) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo !== \"function\") {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (!shallowCompare(indices, next)) {\n            setIndices(next);\n          }\n        }\n\n        return scrollOffset;\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  };\n}\n","import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style?: CSSProperties;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n","import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n","import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n","import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n","import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { ariaAttributes: object; style: CSSProperties },\n  nextProps: { ariaAttributes: object; style: CSSProperties }\n): boolean {\n  const {\n    ariaAttributes: prevAriaAttributes,\n    style: prevStyle,\n    ...prevRest\n  } = prevProps;\n  const {\n    ariaAttributes: nextAriaAttributes,\n    style: nextStyle,\n    ...nextRest\n  } = nextProps;\n\n  return (\n    shallowCompare(prevAriaAttributes, nextAriaAttributes) &&\n    shallowCompare(prevStyle, nextStyle) &&\n    shallowCompare(prevRest, nextRest)\n  );\n}\n"],"names":["Block","children","className","rest","ErrorBoundary","jsx","parseNumericStyleValue","value","endsWith","parseFloat","cachedRTLResult","adjustScrollOffsetForRtl","containerElement","direction","isRtl","scrollOffset","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","getRTLOffsetType","clientWidth","scrollWidth","assert","expectedCondition","message","console","error","Error","shallowCompare","a","b","Object","keys","length","key","is","getEstimatedSize","cachedBounds","itemCount","itemSize","bounds","get","size","getStartStopIndices","containerScrollOffset","containerSize","overscanCount","maxIndex","startIndexVisible","stopIndexVisible","startIndexOverscan","stopIndexOverscan","currentIndex","Math","max","min","useCachedBounds","itemProps","useMemo","cache","Map","index","set","previousRowBounds","createCachedBounds","useVirtualizer","containerStyle","defaultContainerSize","itemSizeProp","onResize","indices","setIndices","useState","box","defaultHeight","defaultWidth","disabled","disabledProp","element","mode","styleHeight","styleWidth","state","setState","useIsomorphicLayoutEffect","resizeObserver","ResizeObserver","entries","entry","contentRect","target","prevState","observe","unobserve","useResizeObserver","prevSizeRef","useRef","parseInt","useItemSize","useLayoutEffect","prevSize","current","getCellBounds","useCallback","getEstimatedSizeUtil","getStartStopIndicesUtil","scrollTop","onScroll","prev","next","addEventListener","removeEventListener","scrollToIndex","fn","ref","args","useStableCallback","align","estimatedTotalSize","maxOffset","minOffset","getOffsetForIndex","scrollTo","useMemoizedObject","unstableObject","values","arePropsEqual","prevProps","nextProps","ariaAttributes","prevAriaAttributes","prevStyle","prevRest","nextAriaAttributes","nextStyle","nextRest"],"mappings":"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"}